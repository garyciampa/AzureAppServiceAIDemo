<!-- Use this file to provide workspace-specific custom instructions to Copilot. For more details, visit https://code.visualstudio.com/docs/copilot/copilot-customization#_use-a-githubcopilotinstructionsmd-file -->

# Copilot Instructions for Azure App Service AI Demo

## Model Preference
**Preferred Model**: Claude Sonnet 4 - Use this model for all interactions with this workspace for optimal performance with complex Azure architecture, Python Flask development, and AI service integrations.

This is a Python Flask web application designed to run on Azure App Service with the following key features:

## Project Structure
- **Flask web application** with Azure AD OAuth authentication
- **Frontend**: Bootstrap-based responsive UI with input/output dialogs
- **Backend**: Flask routes handling authentication and prompt processing
- **Deployment**: Configured for Azure App Service

## Key Components
1. **Azure AD Authentication**: Uses MSAL library for OAuth flow
2. **Input Dialog**: Text area for user prompts with send/clear buttons
3. **Output Dialog**: Display area for responses with clear button
4. **Session Management**: Secure token caching and user sessions

## Development Guidelines
- Follow Flask best practices for route handling and templating
- Use Bootstrap classes for consistent UI styling
- Implement proper error handling for authentication flows
- Keep sensitive configuration in environment variables (do not commit secrets)
- Use async/await patterns for API calls in JavaScript where appropriate
- Use typed function signatures and docstrings in Python for clarity and better tooling support
- Use automated formatting and linting (see Code Style section)

## Code Style (Python/Frontend)
- Follow PEP 8 and idiomatic Python. Use tools like:
  - black (formatting)
  - isort (imports)
  - flake8 (linting)
  - mypy (optional static type checking)
- Use pre-commit hooks to run formatting and linting on commit
- Keep lines <= 88 characters (black default) and favor readability
- Write expressive variable and function names and avoid deeply nested blocks

## Documentation
- Provide module, class, and function docstrings using a consistent style (Google or NumPy style recommended)
- Include type hints for public interfaces where useful; this helps mypy and editors
- Maintain a clear README with:
  - Purpose and overview
  - How to run locally
  - Environment variables required
  - Deployment notes for Azure App Service
- Keep a changelog or use conventional commits for meaningful history
- For public APIs, consider generating docs with Sphinx (autodoc) or MkDocs

## Error Handling and Try/Except Best Practices
- Catch specific exceptions, not bare `except:` blocks. Example:
  - Good: except (requests.Timeout, requests.ConnectionError) as ex:
  - Bad: except Exception: pass
- When catching exceptions, log sufficient context and either handle or re-raise with `raise` to preserve the traceback
- Use Flask error handlers to centralize HTTP error responses:
  - @app.errorhandler(400) / @app.errorhandler(Exception)
  - Return consistent JSON error shapes for API endpoints
- Use custom exception classes for domain-specific errors
- Prefer context managers (with ...) to manage resources safely
- Use retries with backoff (e.g., tenacity) for idempotent external calls and surface meaningful error messages to users

## Logging and Observability
- Use the Flask app logger (app.logger) or a configured logging module
- Log at the appropriate level: debug/info/warning/error/critical
- Do not log secrets or PII; redact sensitive values in logs
- Ensure logging is configured for production (structured logs, log rotation or ingestion to App Insights / Log Analytics)

## Security and Configuration
- Store secrets in environment variables or Azure Key Vault; do NOT commit secrets
- Validate and sanitize any user input before use
- Use HTTPS in production and secure cookie/session settings for Flask
- Limit token lifetimes and properly handle refresh/expiration logic for Azure AD

## Testing and CI
- Add tests with pytest and assert expected behavior for routes and helper code
- Aim for meaningful unit and integration tests (mock external services when possible)
- Include test runs and linters in CI (GitHub Actions) to ensure code quality on PRs

## AI-Generated Code Policy and Comment Attribution
- All AI-generated code must include a short comment at the top indicating:
  1) That it was generated by an AI model
  2) The model used (e.g., Claude Sonnet 4)
  3) Date (ISO 8601 preferred) and a brief one-line description of the change/intent.
- Example comment formats to place at the top of files or generated snippets:
  - Python (module or script):
    # Generated with Claude Sonnet 4 - 2025-09-03 - Implemented helper for Azure AD token cache
  - JavaScript/TypeScript:
    // Generated with Claude Sonnet 4 - 2025-09-03 - Async helper for fetch requests
  - HTML:
    <!-- Generated with Claude Sonnet 4 - 2025-09-03 - New modal dialog markup -->
- Additionally, include a short in-file comment (one line) near non-trivial generated logic to explain intent and list any assumptions made by the AI.

## Commit Messages and PRs
- Use concise, descriptive commit messages. Prefer Conventional Commits (feat:, fix:, docs:, style:, refactor:, test:, chore:)
- When including AI-generated code in a PR, add a short note in the PR description listing which files or sections were generated by the AI and why

## Maintenance and Dependencies
- Keep requirements.txt or requirements_dev.txt up to date and use a virtual environment
- Pin direct dependencies where possible and run periodic dependency updates with security scanning

## Example: Robust try/except handling in a Flask route
- Use specific exceptions, logging, and return useful HTTP responses. E.g.:
  - try:
      ...
    except SomeExternalServiceError as ex:
      app.logger.error("External service failed: %s", ex)
      return (jsonify({"error": "external_service_unavailable"}), 503)
    except Exception as ex:
      app.logger.exception("Unexpected error while processing request")
      return (jsonify({"error": "internal_server_error"}), 500)

## Azure Integration
- Configured for Azure App Service deployment
- Uses Azure AD for authentication
- Ready for integration with Azure AI services
- Environment variables for secure configuration

When working on this project, prioritize security, user experience, maintainability, and Azure best practices.
